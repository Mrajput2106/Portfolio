<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Monster Shooter — Mobile Friendly</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html,body{
    height:100%; margin:0; background:#111; font-family:Arial; color:#fff;
    display:flex; justify-content:center; align-items:center;
    min-height:100vh;
  }
  #phone{
    width:360px; max-width:98vw;
    height:720px; max-height:98vh;
    background:#000; border-radius:18px;
    position:relative; overflow:hidden;
    box-shadow:0 0 30px #000;
    display:flex; flex-direction:column;
  }
  #gameArea{
    flex:1;
    display:flex; justify-content:center; align-items:center;
    position:relative;
    background:#000;
  }
  canvas{
    background:#000;
    width:100%; max-width:100%;
    height:100%; max-height:100%;
    display:block;
  }
  #controls{
    height:120px; min-height:85px;
    width:100%; background:transparent;
    display:flex; justify-content:space-between; align-items:flex-end;
    position:relative; padding:6px; box-sizing:border-box;
  }
  #fireBtn{
    width:66px; height:66px; background:#ff3333; border-radius:999px;
    display:flex; align-items:center; justify-content:center;
    font-size:20px; font-weight:bold; user-select:none;
    border:3px solid rgba(255,255,255,0.2);
    touch-action:none;
  }
  .moveBtn{
    width:54px; height:54px;
    background:#222; border-radius:14px; border:3px solid #555;
    display:flex; align-items:center; justify-content:center;
    font-size:32px; user-select:none;
    touch-action:none;
  }
  #move{
    display:flex; flex-direction:column; align-items:center; gap:4px;
  }
  #leftRight{
    display:flex; gap:4px;
  }
  .overlay{
    position:absolute; inset:0; background:#000a; z-index:20;
    display:flex; flex-direction:column; justify-content:center;
    align-items:center;
  }
  .btn{
    padding:16px 28px; background:#007aff; border-radius:12px;
    font-size:20px; cursor:pointer; margin-top:20px;
  }
  #highScore{
    position:absolute; top:8px; right:18px; z-index:25;
    padding:8px 12px;
    background:#222b; color:#ffeb3b;
    font-weight:bold; font-size:21px; border-radius:10px;
    pointer-events:none;
    font-family:Arial,sans-serif;
  }
</style>
</head>
<body>
<div id="phone">
  <div id="gameArea">
    <div id="highScore">High Score: 0</div>
    <canvas id="game" width="600" height="700"></canvas>
  </div>
  <div id="startScreen" class="overlay">
    <h2>MONSTER SHOOTER</h2>
    <div id="startBtn" class="btn">START</div>
  </div>
  <div id="retryScreen" class="overlay" style="display:none">
    <h2>GAME OVER</h2>
    <div id="retryBtn" class="btn">RETRY</div>
  </div>
  <div id="controls">
    <div id="fireBtn">FIRE</div>
    <div id="move">
      <div id="up" class="moveBtn">▲</div>
      <div id="leftRight">
        <div id="left" class="moveBtn">◀</div>
        <div id="right" class="moveBtn">▶</div>
      </div>
      <div id="down" class="moveBtn">▼</div>
    </div>
  </div>
</div>
<script>
/* -------- Responsive Canvas Sizing -------- */
const W = 600, H = 700;
function fitCanvas() {
  let phone = document.getElementById('phone');
  let gameArea = document.getElementById('gameArea');
  let canvas = document.getElementById('game');
  let areaW = gameArea.clientWidth, areaH = gameArea.clientHeight;
  let scale = Math.min(areaW / W, areaH / H);
  canvas.style.width  = (W*scale) + 'px';
  canvas.style.height = (H*scale) + 'px';
}
window.addEventListener('resize', fitCanvas);
window.addEventListener('orientationchange', fitCanvas);
setTimeout(fitCanvas,100);


/* --------- High Score LocalStorage --------- */
const SCORE_KEY = 'monsterShooterHighScore';
function getHighScore() {
  return parseInt(localStorage.getItem(SCORE_KEY) || '0', 10);
}
function setHighScore(val) {
  localStorage.setItem(SCORE_KEY, val+'');
}
function showHighScore(val) {
  document.getElementById('highScore').textContent = 'High Score: ' + val;
}
showHighScore(getHighScore());


/* ---------------- GAME LOGIC ---------------- */
let gameStarted = false;
let lastFrame = performance.now();
const CONTROL_HEIGHT = 120;
const SAFE_BOTTOM = H - CONTROL_HEIGHT - 6;

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const HERO_SIZE = 40, HERO_X = 250, HERO_Y = 500;
  const BASE_HERO_SPEED = 540; // increased base hero speed
  const BULLET_SPEED = 700;
  const BASE_MONSTER_SPEED = 140;
  const MONSTER_BULLET_SPEED = 400;

  let heroX, heroY, bullets, monsters, score, gameOver, monsterSpeed, spawnRate;
  let monsterBullets = [];
  let isMonstersFrozen = false;
  let freezeStartTime = 0;
  const FREEZE_DURATION = 5000; // 5 seconds freeze

  window.moveLeft=false;
  window.moveRight=false;
  window.moveUp=false;
  window.moveDown=false;
  window.mouseHeld=false;

  function reset(){
    heroX=HERO_X; heroY=HERO_Y;
    bullets=[];
    monsters=[];
    monsterBullets = [];
    score=0; gameOver=false;
    monsterSpeed=BASE_MONSTER_SPEED;
    spawnRate=50;
    lastFrame = performance.now();
    isMonstersFrozen=false;
    freezeStartTime=0;
    heroY = Math.min(heroY, SAFE_BOTTOM - HERO_SIZE);
  }
  window.globalReset = reset;

  function intersect(a,b){
    return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y);
  }
  window.globalGameOver = ()=>{
    gameOver=true;
    document.getElementById("retryScreen").style.display="flex";
  };

  function draw(){
    ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
    ctx.fillStyle="#0ff"; ctx.fillRect(heroX,heroY,HERO_SIZE,HERO_SIZE);
    ctx.fillStyle="#ff0";
    bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
    ctx.fillStyle="#f44";
    monsters.forEach(m=>ctx.fillRect(m.x,m.y,m.w,m.h));
    ctx.fillStyle="#f8a"; // monster bullets color (pinkish)
    monsterBullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
    ctx.fillStyle="#fff"; ctx.font="22px Arial";
    ctx.fillText("Score: "+score,20,40);
  }

  let fireCooldown = 0;
  let monsterFireCooldown = 0;

  function tick(now){
    let dt = Math.min((now - lastFrame) / 1000, 0.04);
    lastFrame = now;
    if(!gameStarted || gameOver) { requestAnimationFrame(tick); return; }

    // Hero speed increases with score continuously
    let heroSpeed = BASE_HERO_SPEED + score * 10; // +10 px/sec per score
    if(moveLeft)  heroX -= heroSpeed * dt;
    if(moveRight) heroX += heroSpeed * dt;
    if(moveUp)    heroY -= heroSpeed * dt;
    if(moveDown)  heroY += heroSpeed * dt;

    heroX = Math.max(0, Math.min(W-HERO_SIZE, heroX));
    heroY = Math.max(0, Math.min(SAFE_BOTTOM-HERO_SIZE, heroY));

    // Bullet firing (hero)
    fireCooldown -= dt;
    if(mouseHeld && fireCooldown <= 0){
      bullets.push({x:heroX+15,y:heroY,w:10,h:20});
      fireCooldown = 0.11; // ~9/sec
    }

    // Increase monster speed and spawn frequency as score grows
    if(!isMonstersFrozen) {
      monsterSpeed = BASE_MONSTER_SPEED + score * 5; // +5 px/sec per score
      spawnRate = Math.max(12, 50 - Math.floor(score/2)); // spawn rate decreases with score but min 12
    }

    if(Math.random()*spawnRate < dt*spawnRate && !isMonstersFrozen)
      monsters.push({x:Math.random()*(W-40),y:0,w:40,h:40});

    // Move bullets (hero)
    bullets.forEach(b=> b.y -= BULLET_SPEED*dt );
    bullets = bullets.filter(b=>b.y>0);

    // Check monster freeze condition at score 40
    if(score >= 40 && !isMonstersFrozen){
      // Freeze monsters and start firing
      isMonstersFrozen = true;
      freezeStartTime = now;
    }

    // Monster behavior when frozen
    if(isMonstersFrozen){
      // Freeze monsters: no vertical movement
      // Monster firing bullets at hero every 0.7 seconds
      monsterFireCooldown -= dt;
      if(monsterFireCooldown <= 0){
        monsterFireCooldown = 0.7;
        monsters.forEach(m => {
          // Fire bullet from monster center downward horizontally aiming at hero position (simple horizontal aiming)
          // Create bullet starting at bottom center of monster
          let bulletX = m.x + m.w/2 - 7; // bullet width ~14
          let bulletY = m.y + m.h;
          // Calculate horizontal speed component towards heroX, normalized horizontally only
          let diffX = heroX + HERO_SIZE/2 - bulletX;
          let speedX = 0;
          if(diffX !== 0) {
            speedX = (diffX > 0) ? 150 : -150; // horizontal speed component
          }
          monsterBullets.push({
            x: bulletX,
            y: bulletY,
            w: 14,
            h: 14,
            vx: speedX,
            vy: MONSTER_BULLET_SPEED
          });
        });
      }
      // Monster bullets movement
      monsterBullets.forEach(b => {
        b.x += b.vx * dt;
        b.y += b.vy * dt;
      });
      // Remove monster bullets offscreen
      monsterBullets = monsterBullets.filter(b => b.y < H && b.x > 0 && b.x < W);

      // After freeze duration, revert to normal behavior
      if(now - freezeStartTime > FREEZE_DURATION){
        isMonstersFrozen = false;
        monsterBullets = [];
      }
    } else {
      // Normal monster movement (vertical)
      for(let m=monsters.length-1;m>=0;m--){
        monsters[m].y += monsterSpeed*dt;
        if(monsters[m].y>H) window.globalGameOver();
      }
      // Monster bullets cleared when not firing during freeze
      monsterBullets = [];
    }

    // Collision checks: hero bullets vs monsters
    for(let bi=bullets.length-1; bi>=0; bi--){
      let b = bullets[bi];
      let hitIndex = -1;
      for(let mi=0; mi<monsters.length; mi++){
        if(intersect({x:b.x,y:b.y,w:b.w,h:b.h}, monsters[mi])){
          hitIndex = mi;
          break;
        }
      }
      if(hitIndex >= 0){
        monsters.splice(hitIndex,1);
        bullets.splice(bi,1);
        score++;
      }
    }

    // Collision checks: monster bullets vs hero
    for(let bi=monsterBullets.length-1; bi>=0; bi--){
      let b = monsterBullets[bi];
      let heroRect = {x:heroX,y:heroY,w:HERO_SIZE,h:HERO_SIZE};
      if(intersect(b, heroRect)){
        window.globalGameOver();
      }
    }

    // Update high score
    if(score > getHighScore()){
      setHighScore(score);
      showHighScore(score);
    }

    draw();
    requestAnimationFrame(tick);
  }

  reset();
  requestAnimationFrame(tick);
})();


/* FIXED INPUT (pointer events for multitouch) */
function bind(id, down, up){
  const el=document.getElementById(id);
  el.addEventListener("pointerdown", e=>{e.preventDefault(); down();});
  el.addEventListener("pointerup",   e=>{e.preventDefault(); up();});
  el.addEventListener("pointerleave",e=>{e.preventDefault(); up();});
}
bind("left", ()=>moveLeft=true,  ()=>moveLeft=false);
bind("right",()=>moveRight=true, ()=>moveRight=false);
bind("up",   ()=>moveUp=true,    ()=>moveUp=false);
bind("down", ()=>moveDown=true,  ()=>moveDown=false);
bind("fireBtn",()=>mouseHeld=true,()=>mouseHeld=false);


/* start / retry */
document.getElementById("startBtn").onclick = ()=>{
  document.getElementById("startScreen").style.display="none";
  gameStarted=true; globalReset();
  fitCanvas();
};
document.getElementById("retryBtn").onclick = ()=>{
  document.getElementById("retryScreen").style.display="none";
  gameStarted=true; globalReset();
  fitCanvas();
};
</script>
</body>
</html>
